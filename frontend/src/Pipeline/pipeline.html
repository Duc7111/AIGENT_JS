<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Aileron</title>
    <link rel="stylesheet" href="../css/pipeline.css" />
    <script src="pipeline.js"></script>
  </head>
  <body>
    <div id="main">
      <div id="header">
        <div id="header-left">
          <img id="ic-back" class="ic" src="../image/ic_back.svg" />
          <input
            type="text"
            id="btn-project"
            class="btn"
            value="Project Name"
            readonly
          />
          <img id="ic-edit" class="ic" src="../image/ic_edit.svg" />
        </div>
        <div id="header-right">
          <img id="ic-save" class="ic" src="../image/ic_save.svg" />
          <img id="ic-setting" class="ic" src="../image/setting_icon.svg" />
        </div>
      </div>

      <div class="content">
        <div class="content-bar">
          <div class="bar-left">
            <img id="ic-plus" class="ic" src="../image/ic_plus.svg" />
          </div>

          <div class="bar-right">
            <button id="btn-run">Run</button>
            <button id="btn-export" class="btn">
              <img src="../image/ic_export.svg" />
              <span class="btn-content">Export</span>
            </button>
          </div>
        </div>

        <div class="main-content">
          <div class="side-menu">
            <div class="search-box">
              <img src="../image/ic_search.svg" />
              <input type="text" placeholder="Search" id="searchInput" />
            </div>

            <!-- Search result -->
            <div class="search-result">
              <div class="menu-header" style="color: rgba(0, 255, 255, 0.707)">
                <div>Search Result</div>
              </div>
              <div class="menu-item"></div>
            </div>

            <!-- IO module -->
            <div class="menu-section">
              <div class="menu-header">
                <span>Input/Output</span>
                <img src="../image/ic_arrow_down.svg" class="ic-expand" />
              </div>
              <div class="menu-item">
                <div class="item">
                  <span
                    class="item-name"
                    f-name="FileReader"
                    module-name="FileReader"
                    file-module="IO"
                    input-name="FileReader_Input"
                    output-name="FileReader_Output"
                    >File Reader</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="FileWriter"
                    module-name="FileWriter"
                    file-module="IO"
                    input-name="FileWriter_Input"
                    output-name="FileWriter_Output"
                    >File Writer</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="TextHolder"
                    module-name="TextHolder"
                    file-module="IO"
                    input-name="TextHolder_Input"
                    output-name="TextHolder_Output"
                    >Text Holder</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="TextGetter"
                    module-name="TextGetter"
                    file-module="IO"
                    input-name="TextGetter_Input"
                    output-name="TextGetter_Output"
                    >Text Getter</span
                  >
                </div>

                <div class="item">
                  <span
                    class="item-name"
                    f-name="VectorHolder"
                    module-name="VectorHolder"
                    file-module="IO"
                    input-name="VectorHolder_Input"
                    output-name="VectorHolder_Output"
                    >Vector Holder</span
                  >
                </div>
              </div>
            </div>

            <!-- Hugging Face -->
            <div class="menu-section">
              <div class="menu-header">
                <span>Hugging Face</span>
                <img src="../image/ic_arrow_down.svg" class="ic-expand" />
              </div>
              <div class="menu-item">
                <div class="item">
                  <span
                    class="item-name"
                    f-name="Model"
                    module-name="Model"
                    file-module="HuggingFace"
                    input-name="Model_Input"
                    output-name="Model_Output"
                    >Model</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="Tokenizer"
                    module-name="Tokenizer"
                    file-module="HuggingFace"
                    input-name="Tokenizer_Input"
                    output-name="Tokenizer_Output"
                    >Tokenizer</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="Pipeline"
                    module-name="Pipeline"
                    file-module="HuggingFace"
                    input-name="Pipeline_Input"
                    output-name="Pipeline_Output"
                    >Pipeline</span
                  >
                </div>
              </div>
            </div>

            <!-- NN -->
            <div class="menu-section">
              <div class="menu-header">
                <span>Neural Network</span>
                <img src="../image/ic_arrow_down.svg" class="ic-expand" />
              </div>
              <div class="menu-item">
                <div class="item">
                  <span
                    class="item-name"
                    f-name="Perceptron"
                    module-name="Perceptron"
                    file-module="NN"
                    input-name="Perceptron_Input"
                    output-name="Perceptron_Output"
                    >Perceptron</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="NeuralUnit"
                    module-name="NeuralUnit"
                    file-module="NN"
                    input-name="NeuralUnit_Input"
                    output-name="NeuralUnit_Output"
                    >NeuralUnit</span
                  >
                </div>

                <div class="item">
                  <span
                    class="item-name"
                    f-name="InputLayer"
                    module-name="NeuralUnit"
                    file-module="NN"
                    input-name="InputLayer_Input"
                    output-name="InputLayer_Output"
                    >Input Layer</span
                  >
                </div>

                <div class="item">
                  <span
                    class="item-name"
                    f-name="FullyHiddenLayer"
                    module-name="NeuralUnit"
                    file-module="NN"
                    input-name="FullyHiddenLayer_Input"
                    output-name="FullyHiddenLayer_Output"
                    >FullyHiddenLayer</span
                  >
                </div>

                <div class="item">
                  <span
                    class="item-name"
                    f-name="OutputLayer"
                    module-name="NeuralUnit"
                    file-module="NN"
                    input-name="OutputLayer_Input"
                    output-name="OutputLayer_Output"
                    >Output Layer</span
                  >
                </div>
              </div>
            </div>

            <!-- Caster -->
            <div class="menu-section">
              <div class="menu-header">
                <span>Caster</span>
                <img src="../image/ic_arrow_down.svg" class="ic-expand" />
              </div>
              <div class="menu-item">
                <div class="item">
                  <span
                    class="item-name"
                    f-name="DictSplitter"
                    module-name="DictSplitter"
                    file-module="Caster"
                    input-name="DictSplitter_Input"
                    output-name="DictSplitter_Output"
                    >Dict Splitter</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="DictMerger"
                    module-name="DictMerger"
                    file-module="Caster"
                    input-name="DictMerger_Input"
                    output-name="DictMerger_Output"
                    >Dict Merger</span
                  >
                </div>
                <div class="item">
                  <span
                    class="item-name"
                    f-name="ArraySplitter"
                    module-name="ArraySplitter"
                    file-module="Caster"
                    input-name="ArraySplitter_Input"
                    output-name="ArraySplitter_Output"
                    >Array Splitter</span
                  >
                </div>

                <div class="item">
                  <span
                    class="item-name"
                    f-name="ArrayMerger"
                    module-name="ArrayMerger"
                    file-module="Caster"
                    input-name="ArrayMerger_Input"
                    output-name="ArrayMerger_Output"
                    >Array Merger</span
                  >
                </div>
              </div>
            </div>

            <!-- User -->
            <div class="menu-section" id="menu-user">
              <div class="menu-header">
                <span>User</span>
                <img src="../image/ic_arrow_down.svg" class="ic-expand" />
              </div>
              <div class="menu-item"></div>
            </div>
          </div>

          <div id="workspace">
            <canvas id="gridCanvas"></canvas>
          </div>
        </div>
      </div>
    </div>

    <script>
      // function export
      const btnExport = document.getElementById("btn-export");
      btnExport.addEventListener("click", function () {
        const path2Files = [
          draggableItems,
          parentDirectory,
          projectNameInput.value,
        ];
        //window.electron.saveJsonToFile(path2Files);
        window.electron.exportToJsonl(path2Files);
      });

      document.getElementById("ic-back").addEventListener("click", () => {
        window.electron.navigateBack();
        const transferData = [
          draggableItems,
          parentDirectory,
          projectNameInput.value,
        ];
        window.electron.saveJsonToFile(transferData);
      });

      const btn_run = document.getElementById("btn-run");
      btn_run.addEventListener("click", function () {
        window.electron.runPipeline();
      });

      const currentUrl = window.location.href;
      const currentWorkingDirectory = new URL(currentUrl).pathname;

      //split the URL by '/' to get the current working directory
      const pathParts = currentWorkingDirectory.split("/");

      // Discard the last 5 parts of the URL to get the parent directory
      pathParts.pop();
      pathParts.pop();
      pathParts.pop();
      pathParts.pop();

      // Create the parent directory path
      let parentDirectory = pathParts.join("/");
      parentDirectory = parentDirectory + "/__cache__";
      parentDirectory = parentDirectory.substring(1);
      parentDirectory = parentDirectory
        .replace(/%20/g, " ")
        .replace(/\\/g, "\\\\");
      console.log("Parent Directory:", parentDirectory);

      //Function: save pipeline
      const icSave = document.getElementById("ic-save");
      icSave.addEventListener("click", function () {
        console.log(draggableItems);
        const transferData = [
          draggableItems,
          parentDirectory,
          projectNameInput.value,
        ];
        console.log("Transfer Data:", transferData);
        window.electron.saveJsonToFile(transferData);
        //window.electron.savePipeline();
      });

      // open/close side menu
      const icPlus = document.getElementById("ic-plus");
      const sideMenu = document.querySelector(".side-menu");
      icPlus.addEventListener("click", function () {
        sideMenu.style.display =
          sideMenu.style.display === "none" ? "block" : "none";
        const icon_icPlus = icPlus.getAttribute("src");
        icPlus.setAttribute(
          "src",
          icon_icPlus.includes("ic_minus")
            ? "../image/ic_plus.svg"
            : "../image/ic_minus.svg"
        );
      });

      // edit project name
      const editIcon = document.getElementById("ic-edit");
      const projectNameInput = document.getElementById("btn-project");
      let clickInside = false;
      let projectNameCurrent = "";
      editIcon.addEventListener("click", async () => {
        clickInside = true;
        projectNameCurrent = projectNameInput.value;
        listAvailableProjectName =
          await window.electron.receivedListProjectName();
        console.log("Project Names in edit:", listAvailableProjectName);
        await enableEdit();
      });

      document.addEventListener("click", (event) => {
        const targetElement = event.target;

        //
        if (targetElement != editIcon && clickInside) {
          saveProjectName();
        }
      });

      function enableEdit() {
        projectNameInput.removeAttribute("readonly");
        projectNameInput.focus();

        if (projectNameInput) {
          const length = projectNameInput.value.length;

          // move pointer to end of text
          projectNameInput.setSelectionRange(length, length);
        }
      }

      function saveProjectName() {
        clickInside = false;
        projectNameInput.setAttribute("readonly", true);
        const updatedProjectName = projectNameInput.value;
        console.log("Updated Project Name: ", updatedProjectName);

        if (updatedProjectName !== projectNameCurrent) {
          if (listAvailableProjectName.includes(updatedProjectName)) {
            projectNameInput.value = projectNameCurrent;
          }
        }
      }

      projectNameInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          saveProjectName();
        }
      });

      let draggableItems = [];
      let listAvailableProjectName = [];
      let receivedData;

      document.addEventListener("DOMContentLoaded", function () {
        // get params from the homepage
        const urlParams = new URLSearchParams(window.location.search);
        const namesString = urlParams.get("names");
        const names = JSON.parse(namesString);
        console.log("Pass Params:", names);
        if (names) {
          const uniqueProjectName = getUniqueName(names);
          projectNameInput.value = uniqueProjectName;
          const givenFileNamePath = `${parentDirectory}/${uniqueProjectName}.ui.json`;
          getDataFromGivenFile(givenFileNamePath);
        } else {
          getProjectNames();
          generateUniqueProjectName();
        }

        async function generateUniqueProjectName() {
          const defaultProjectName = projectNameInput.value;
          let projectIndex = 1;
          let newProjectName = defaultProjectName;
          await getProjectNames();
          console.log(
            "Project Names in generateUniqueProjectName():",
            listAvailableProjectName
          );

          while (listAvailableProjectName.includes(newProjectName)) {
            newProjectName = `${defaultProjectName}${projectIndex}`;
            ++projectIndex;
          }
          projectNameInput.value = newProjectName;
        }

        async function getProjectNames() {
          listAvailableProjectName =
            await window.electron.receivedListProjectName();
          console.log(
            "Project Names in getProjectNames():",
            listAvailableProjectName
          );
        }

        async function getReceivedData() {
          receivedData = await window.electron.receivedData();
          console.log("Received Data:", receivedData);
          receivedData = JSON.parse(receivedData);
          console.log("Received Data Inputs:", receivedData.outputs.inputs);
          console.log("Received Data Outputs:", receivedData.outputs.outputs);
        }

        async function getDataFromGivenFile(givenFilePath) {
          const dataFile = await window.electron.readFileGivenName(
            givenFilePath
          );
          draggableItems = JSON.parse(dataFile);
          console.log("Data from given file:", draggableItems);
          drawItems();
        }

        // add side menu with user's modules
        const menuUser = document.getElementById("menu-user");
        const menuItemUser = menuUser.querySelector(".menu-item");
        menuItemUser.style.display = "none";
        let isMenuUserOpen = false;

        const iconExpandUser = menuUser.querySelector(".ic-expand");
        iconExpandUser.setAttribute("src", "../image/ic_arrow_up.svg");

        const currentProjectName = projectNameInput.value;
        addModuleUserToMenu().then(() => {
          isMenuUserOpen = true;
          const menuItemsUser = document.querySelectorAll("#menu-item .item");
          console.log("Menu Items Inner:", menuItems);
          menuItemsUser.forEach((item) => {
            item.draggable = true;
            item.addEventListener("dragstart", function (e) {
              if (isMenuUserOpen) {
                const originalItemName123 =
                  e.target.querySelector(".item-name").textContent;
                const itemName123 = generateUniqueItemName(originalItemName123);
                e.dataTransfer.setData("text/plain", itemName123);
              }
            });
          });
        });

        async function addModuleUserToMenu() {
          await getProjectNames();
          console.log(
            "List Available Project Name below menu:",
            listAvailableProjectName
          );
          console.log("Parent Directory in addMenuUser:", parentDirectory);
          listAvailableProjectName.forEach((projectNameUser) => {
            const projectNameWithoutSpace = projectNameUser.split(" ").join("");
            const fileUiPath = `${parentDirectory}/${projectNameWithoutSpace}.json`;
            const inputName = `${projectNameWithoutSpace}_Input`;
            const outputName = `${projectNameWithoutSpace}_Output`;
            const itemUser = document.createElement("div");
            itemUser.className = "item";
            itemUser.draggable = true;
            itemUser.innerHTML = `
            <span
            class="item-name"
            f-name= "${projectNameWithoutSpace}"
            module-name= "${projectNameWithoutSpace}"
            file-module= "${fileUiPath}"
            input-name= "${inputName}"
            output-name= "${outputName}"
            >${projectNameUser}</span
          >
            `;
            menuItemUser.appendChild(itemUser);
          });
        }

        //get unique file name
        function getUniqueName(listNames) {
          const uniqueNames = new Set();

          listNames.forEach((fileName) => {
            // use regex to remove the .json and .UI.json extensions
            const baseName = fileName.replace(/\.ui\.json|\.json$/, "");

            // add the base name to the set
            uniqueNames.add(baseName);
          });

          // convert the set to an array
          const uniqueNameArray = Array.from(uniqueNames);

          return uniqueNameArray;
        }

        // show default first section in the new access
        const menuSections = document.querySelectorAll(".menu-section");
        for (let i = 1; i < menuSections.length; i++) {
          const menuSection = menuSections[i];
          const menuItem = menuSection.querySelector(".menu-item");
          menuItem.style.display = "none";

          const iconExpand = menuSection.querySelector(".ic-expand");
          iconExpand.setAttribute("src", "../image/ic_arrow_up.svg");
        }

        // Expand the menu section when toggle display of menu item
        const menuHeaders = document.querySelectorAll(".menu-header");
        var menuItems = document.querySelectorAll(".menu-item .item");
        console.log("Menu Items Outer:", menuItems);

        menuHeaders.forEach((header) => {
          const menuItem = header.nextElementSibling;
          const iconExpand = header.querySelector(".ic-expand");

          header.addEventListener("click", () => {
            menuItem.style.display =
              menuItem.style.display === "none" ? "flex" : "none";
            const iconSrc = iconExpand.getAttribute("src");
            iconExpand.setAttribute(
              "src",
              iconSrc.includes("ic_arrow_down.svg")
                ? "../image/ic_arrow_up.svg"
                : "../image/ic_arrow_down.svg"
            );
          });
        });

        // Not shown the search result initially
        const searchResult = document.querySelector(".search-result");
        const searchItem = searchResult.querySelector(".menu-item");
        searchResult.style.display = "none";

        // Search items
        const searchInput = document.getElementById("searchInput");

        let hasResults = false;
        let search_click = false;
        searchInput.addEventListener("keypress", function (e) {
          const items = document.querySelectorAll(".menu-item .item");
          if (e.key === "Enter") {
            const searchTerm = searchInput.value.trim().toLowerCase();

            searchItem.innerHTML = "";
            hasResults = false;

            if (searchTerm !== "") {
              items.forEach((item) => {
                const itemName = item
                  .querySelector(".item-name")
                  .textContent.toLowerCase();

                if (itemName.includes(searchTerm)) {
                  const cloneItem = item.cloneNode(true);
                  searchItem.appendChild(cloneItem);
                  hasResults = true;
                }
              });
            }

            if (hasResults) {
              searchResult.style.display = "block";
              search_click = true;
              menuItems = document.querySelectorAll(".menu-item .item");
              menuItems.forEach((item) => {
                item.draggable = true;
                item.addEventListener("dragstart", function (e) {
                  if (isMenuUserOpen) {
                    const originalItemName =
                      e.target.querySelector(".item-name").textContent;
                    if (search_click == true) {
                      const itemName = generateUniqueItemName(originalItemName);
                      e.dataTransfer.setData("text/plain", itemName);
                    }
                  }
                });
              });
            } else {
              searchResult.style.display = "none";
              search_click = false;
            }
          }
        });

        // Create and move the canvas
        const workspace = document.getElementById("workspace");
        const canvas = document.getElementById("gridCanvas");
        const ctx = canvas.getContext("2d");
        const gridSize = 40;
        const width = workspace.clientWidth;
        const height = workspace.clientHeight;
        ctx.font = "16px Arial";
        canvas.width = width;
        canvas.height = height;

        function drawGrid() {
          ctx.strokeStyle = "#e0e0e0";
          ctx.beginPath();

          for (let x = 0; x <= width; x += gridSize) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
          }

          for (let y = 0; y <= height; y += gridSize) {
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
          }

          ctx.stroke();
        }

        // drawGrid();

        let isDragging = false;
        let lastPosX = 0;
        let lastPosY = 0;
        let scale = 1;
        const zoomSensitivity = 0.1;

        function getMinimumScale() {
          const workspaceWidth = workspace.clientWidth;
          const workspaceHeight = workspace.clientHeight;
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          const scaleX = workspaceWidth / canvasWidth;
          const scaleY = workspaceHeight / canvasHeight;

          return Math.max(scaleX, scaleY);
        }

        workspace.addEventListener("wheel", function (e) {
          e.preventDefault();

          const delta = e.deltaY * -0.01;
          const oldScale = scale;
          const newPotentialScale = scale + delta * zoomSensitivity;

          const minScale = getMinimumScale();
          scale = Math.max(minScale, newPotentialScale);
          scale = Math.min(scale, 4);

          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / scale;
          const y = (e.clientY - rect.top) / scale;

          const newWidth = canvas.width * scale;
          const newHeight = canvas.height * scale;
          const dx = x * (newWidth / canvas.width - oldScale);
          const dy = y * (newHeight / canvas.height - oldScale);

          workspace.scrollLeft += dx;
          workspace.scrollTop += dy;

          canvas.style.width = `${newWidth}px`;
          canvas.style.height = `${newHeight}px`;
          drawItems();
          drawConnectionLines();
        });

        // Drag and drop functionality
        let unique_item_name = [];
        let draggedItem = null;
        let selectedItemIndex = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        menuItems = document.querySelectorAll(".menu-item .item");
        menuItems.forEach((item) => {
          item.draggable = true;
          item.addEventListener("dragstart", function (e) {
            if (isMenuUserOpen) {
              const originalItemName =
                e.target.querySelector(".item-name").textContent;
              if (search_click == false) {
                const itemName = generateUniqueItemName(originalItemName);
                e.dataTransfer.setData("text/plain", itemName);
              }
            }
          });
        });

        function generateUniqueItemName(itemName) {
          if (!(itemName in unique_item_name)) {
            // First occurrence of this itemName, store count as 1
            unique_item_name[itemName] = 1;
            return itemName;
          } else {
            // Increment the count for this itemName
            unique_item_name[itemName]++;
            const count = unique_item_name[itemName];
            return `${itemName}_${count}`;
          }
        }

        workspace.addEventListener("dragover", function (e) {
          e.preventDefault();
        });

        workspace.addEventListener("drop", function (e) {
          e.preventDefault();
          const itemName = e.dataTransfer
            .getData("text/plain")
            .replace(/\s/g, "");

          // add module to the pipeline
          const draggedElement = document.querySelector(
            `[f-name="${itemName}"]`
          );
          console.log("Drag & Drop:", itemName);
          if (draggedElement) {
            const moduleName = draggedElement.getAttribute("module-name");
            const fileModule = draggedElement.getAttribute("file-module");
            console.log("Item dragged:", itemName);
            console.log("Module Name:", moduleName);
            console.log("File Module:", fileModule);

            window.electron.addModule(itemName, fileModule, moduleName);
            getReceivedData().then(() => {
              const x = e.clientX - workspace.getBoundingClientRect().left;
              const y = e.clientY - workspace.getBoundingClientRect().top;

              let newItem = {
                originalName: itemName,
                name: itemName,
                x: x,
                y: y,
                dragging: false,
                inputs: [],
                outputs: [],
              };

              if (receivedData) {
                newItem.inputs = receivedData.outputs.inputs;
                newItem.outputs = receivedData.outputs.outputs;
              }

              if (itemName.includes("FileReader")) {
                newItem.name = "Click to choose file";
              }

              draggableItems.push(newItem);
              drawItems();
            });
          }
        });

        workspace.addEventListener("click", function (e) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / scale;
          const mouseY = (e.clientY - rect.top) / scale;

          draggableItems.forEach((item) => {
            const hitbox = {
              x: item.x * scale,
              y: (item.y - 16) * scale,
              width: ctx.measureText(item.name).width * scale,
              height: 16 * scale,
            };
            if (
              mouseX >= hitbox.x &&
              mouseX <= hitbox.x + hitbox.width &&
              mouseY >= hitbox.y &&
              mouseY <= hitbox.y + hitbox.height
            ) {
              if (item.originalName.includes("FileReader")) {
                const inputFile = document.createElement("input");
                inputFile.type = "file";
                inputFile.click();

                inputFile.addEventListener("change", function (e) {
                  const selectedFile = e.target.files[0];
                  const pathJson = {
                    file: selectedFile.path,
                  };
                  item.name = selectedFile
                    ? selectedFile.name
                    : "No file chosen";
                  window.electron.setHyperparameters(
                    item.originalName,
                    pathJson
                  );
                  window.electron.outputRegister(
                    item.originalName,
                    item.originalName,
                    "output"
                  );
                  drawItems();
                  console.log("original name:", item.originalName);
                  console.log("Selected file:", JSON.stringify(pathJson));
                });
              }
            }
          });
        });

        function isMouseOverItem(mouseX, mouseY, item) {
          const hitbox = {
            x: item.x * scale,
            y: (item.y - 16) * scale,
            width: ctx.measureText(item.name).width * scale,
            height: 16 * scale,
          };
          return (
            mouseX >= hitbox.x &&
            mouseX <= hitbox.x + hitbox.width &&
            mouseY >= hitbox.y &&
            mouseY <= hitbox.y + hitbox.height
          );
        }
        let isDraggingMarker = false;
        let connectionLines = [];

        let lineStartX = null;
        let lineStartY = null;
        let lineEndX = null;
        let lineEndY = null;
        let srcModuleKey = null;
        let tgtModuleKey = null;
        let srcKey = null;
        let tgtKey = null;

        let startItem = null;
        let endItem = null;

        canvas.addEventListener("mousemove", function (e) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / scale;
          const mouseY = (e.clientY - rect.top) / scale;
          let isOverItem = false;
          let isOverMarker = false;

          draggableItems.forEach((item, index) => {
            if (isMouseOverItem(mouseX, mouseY, item)) {
              isOverItem = true;
              if (selectedItemIndex === null) {
                canvas.style.cursor = "pointer";
              }
            }

            const itemNameWidth = ctx.measureText(item.name).width;
            const itemNameHeight = 16;
            const centerY = item.y - itemNameHeight / 2;

            if (item.inputs) {
              item.inputs.forEach((input, inputIndex) => {
                const inputHitbox = {
                  x: (item.x - 20 - ctx.measureText(input).width) * scale,
                  y:
                    (centerY -
                      (item.inputs.length * 16) / 2 +
                      inputIndex * 32) *
                    scale,
                  width: 12 * scale,
                  height: 16 * scale,
                };
                if (
                  mouseX >= inputHitbox.x &&
                  mouseX <= inputHitbox.x + inputHitbox.width &&
                  mouseY >= inputHitbox.y &&
                  mouseY <= inputHitbox.y + inputHitbox.height
                ) {
                  isOverMarker = true;
                  canvas.style.cursor = "pointer";
                }
              });
            }

            if (item.outputs) {
              item.outputs.forEach((output, outputIndex) => {
                const outputHitbox = {
                  x: (item.x + ctx.measureText(item.name).width + 20) * scale,
                  y:
                    (centerY -
                      (item.outputs.length * 16) / 2 +
                      outputIndex * 32) *
                    scale,
                  width: 12 * scale,
                  height: 16 * scale,
                };
                if (
                  mouseX >= outputHitbox.x &&
                  mouseX <= outputHitbox.x + outputHitbox.width &&
                  mouseY >= outputHitbox.y &&
                  mouseY <= outputHitbox.y + outputHitbox.height
                ) {
                  isOverMarker = true;
                  canvas.style.cursor = "pointer";
                }
              });
            }
          });

          if (!isOverItem && !isOverMarker && selectedItemIndex === null) {
            canvas.style.cursor = "default";
          }

          if (selectedItemIndex !== null) {
            draggableItems[selectedItemIndex].x = mouseX - dragOffsetX;
            draggableItems[selectedItemIndex].y = mouseY - dragOffsetY;

            drawItems();
          }

          if (isDragging) {
            const deltaX = e.clientX - lastPosX;
            const deltaY = e.clientY - lastPosY;
            const rect = workspace.getBoundingClientRect();
            workspace.scrollLeft -= deltaX;
            workspace.scrollTop -= deltaY;
            lastPosX = e.clientX;
            lastPosY = e.clientY;
          }

          if (isDraggingMarker) {
            lineEndX = mouseX;
            lineEndY = mouseY;
          }

          // Redraw items and connection line
          if (isDraggingMarker) {
            lineEndX = null;
            lineEndY = null;
          }
        });

        canvas.addEventListener("mousedown", function (e) {
          isDragging = true;
          lastPosX = e.clientX;
          lastPosY = e.clientY;

          const rect = canvas.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / scale;
          const mouseY = (e.clientY - rect.top) / scale;

          draggableItems.forEach((item, index) => {
            const hitbox = {
              x: item.x * scale,
              y: (item.y - 16) * scale,
              width: ctx.measureText(item.name).width * scale,
              height: 16 * scale,
            };
            if (
              mouseX >= hitbox.x &&
              mouseX <= hitbox.x + hitbox.width &&
              mouseY >= hitbox.y &&
              mouseY <= hitbox.y + hitbox.height
            ) {
              selectedItemIndex = index;
              dragOffsetX = mouseX - hitbox.x;
              dragOffsetY = mouseY - hitbox.y;
              isDragging = false;
            }

            const itemNameWidth = ctx.measureText(item.name).width;
            const itemNameHeight = 16;
            const centerY = item.y - itemNameHeight / 2;

            if (item.inputs) {
              item.inputs.forEach((input, inputIndex) => {
                const inputHitbox = {
                  x: (item.x - 20 - ctx.measureText(input).width) * scale,
                  y:
                    (centerY -
                      (item.inputs.length * 16) / 2 +
                      inputIndex * 32) *
                    scale,
                  width: 12 * scale,
                  height: 16 * scale,
                };
                if (
                  mouseX >= inputHitbox.x &&
                  mouseX <= inputHitbox.x + inputHitbox.width &&
                  mouseY >= inputHitbox.y &&
                  mouseY <= inputHitbox.y + inputHitbox.height
                ) {
                  console.log("Input Marker: ", input);
                  isDraggingMarker = true;
                  startItem = "input";
                  tgtModuleKey = item.originalName;
                  tgtKey = input;
                  lineStartX = inputHitbox.x;
                  lineStartY = inputHitbox.y;
                }
              });
            }

            if (item.outputs) {
              item.outputs.forEach((output, outputIndex) => {
                const outputHitbox = {
                  x: (item.x + ctx.measureText(item.name).width + 20) * scale,
                  y:
                    (centerY -
                      (item.outputs.length * 16) / 2 +
                      outputIndex * 32) *
                    scale,
                  width: 12 * scale,
                  height: 16 * scale,
                };
                if (
                  mouseX >= outputHitbox.x &&
                  mouseX <= outputHitbox.x + outputHitbox.width &&
                  mouseY >= outputHitbox.y &&
                  mouseY <= outputHitbox.y + outputHitbox.height
                ) {
                  console.log("Output Marker: ", output);
                  isDraggingMarker = true;
                  startItem = "output";
                  srcModuleKey = item.originalName;
                  srcKey = output;
                  lineStartX = outputHitbox.x;
                  lineStartY = outputHitbox.y;
                }
              });
            }
          });
        });

        canvas.addEventListener("mouseup", function (e) {
          const rect = canvas.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / scale;
          const mouseY = (e.clientY - rect.top) / scale;
          selectedItemIndex = null;
          isDragging = false;

          if (isDraggingMarker) {
            draggableItems.forEach((item, index) => {
              const itemNameWidth = ctx.measureText(item.name).width;
              const itemNameHeight = 16;
              const centerY = item.y - itemNameHeight / 2;

              if (item.inputs) {
                item.inputs.forEach((input, inputIndex) => {
                  const inputHitbox = {
                    x: item.x - 20 - ctx.measureText(input).width,
                    y:
                      centerY - (item.inputs.length * 16) / 2 + inputIndex * 32,
                    width: 12,
                    height: 16,
                  };
                  if (
                    mouseX >= inputHitbox.x &&
                    mouseX <= inputHitbox.x + inputHitbox.width &&
                    mouseY >= inputHitbox.y &&
                    mouseY <= inputHitbox.y + inputHitbox.height
                  ) {
                    endItem = "input";
                    tgtModuleKey = item.originalName;
                    tgtKey = input;
                    lineEndX = inputHitbox.x;
                    lineEndY = inputHitbox.y;
                  }
                });
              }

              if (item.outputs) {
                item.outputs.forEach((output, outputIndex) => {
                  const outputHitbox = {
                    x: item.x + ctx.measureText(item.name).width + 20,
                    y:
                      centerY -
                      (item.outputs.length * 16) / 2 +
                      outputIndex * 32,
                    width: 12,
                    height: 16,
                  };
                  if (
                    mouseX >= outputHitbox.x &&
                    mouseX <= outputHitbox.x + outputHitbox.width &&
                    mouseY >= outputHitbox.y &&
                    mouseY <= outputHitbox.y + outputHitbox.height
                  ) {
                    endItem = "output";
                    srcModuleKey = item.originalName;
                    srcKey = output;
                    lineEndX = outputHitbox.x;
                    lineEndY = outputHitbox.y;
                  }
                });
              }
            });

            if (areCompatibleMarkers(startItem, endItem)) {
              addConnectionLine(
                lineStartX,
                lineStartY,
                lineEndX,
                lineEndY,
                srcModuleKey,
                tgtModuleKey,
                srcKey,
                tgtKey
              );
              console.log(
                "Connect module test: ",
                srcModuleKey,
                tgtModuleKey,
                srcKey,
                tgtKey
              );
              window.electron.connectModule(
                srcModuleKey,
                tgtModuleKey,
                srcKey,
                tgtKey
              );
            }
          }

          isDraggingMarker = false;
          lineStartX = null;
          lineStartY = null;
          lineEndX = null;
          lineEndY = null;
          startItem = null;
          endItem = null;
          srcModuleKey = null;
          tgtModuleKey = null;
          srcKey = null;
          tgtKey = null;
        });

        canvas.addEventListener("mouseleave", function () {
          selectedItemIndex = null;
          isDragging = false;
        });

        function drawItems() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // drawGrid();
          draggableItems.forEach((item) => {
            ctx.save();
            ctx.scale(scale, scale);
            ctx.fillStyle = "white";
            ctx.fillText(item.name, item.x, item.y);

            const itemNameWidth = ctx.measureText(item.name).width;
            const itemNameHeight = 16; // Font size 16
            const centerY = item.y - itemNameHeight / 2;

            ctx.fillText(item.name, item.x, item.y);

            if (item.inputs) {
              const inputSpacing = 20;
              let inputY = centerY - (item.inputs.length * 16) / 2;
              item.inputs.forEach((input) => {
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(
                  item.x - inputSpacing - ctx.measureText(input).width,
                  inputY,
                  6,
                  0,
                  2 * Math.PI
                );
                ctx.fill();

                ctx.fillStyle = "red";
                ctx.fillText(
                  input,
                  item.x - inputSpacing - ctx.measureText(input).width + 10,
                  inputY + 16
                );

                inputY += 32;
              });
            }

            if (item.outputs) {
              const outputSpacing = 20;
              let outputY = centerY - (item.outputs.length * 16) / 2;
              item.outputs.forEach((output) => {
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(
                  item.x + itemNameWidth + outputSpacing,
                  outputY,
                  6,
                  0,
                  2 * Math.PI
                );
                ctx.fill();

                ctx.fillStyle = "red";
                ctx.fillText(
                  output,
                  item.x + itemNameWidth + outputSpacing + 10,
                  outputY + 16
                );

                outputY += 32;
              });
            }

            ctx.restore();
          });
        }

        function drawConnectionLines() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawItems();
          connectionLines.forEach((line) => {
            ctx.beginPath();
            ctx.moveTo(line.startX * scale, line.startY * scale);
            ctx.lineTo(line.endX * scale, line.endY * scale);
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        }

        function addConnectionLine(
          startX,
          startY,
          endX,
          endY,
          srcModuleKey,
          tgtModuleKey,
          srcKey,
          tgtKey
        ) {
          connectionLines.push({
            startX,
            startY,
            endX,
            endY,
            srcModuleKey,
            tgtModuleKey,
            srcKey,
            tgtKey,
          });
          drawConnectionLines();
        }

        function clearConnectionLines() {
          connectionLines = [];
          drawConnectionLines();
        }

        function areCompatibleMarkers(startItem, endItem) {
          if (startItem === "input" && endItem === "output") {
            return true;
          }
          if (startItem === "output" && endItem === "input") {
            return true;
          }
          return false;
        }
      });
    </script>
  </body>
</html>
